#!/usr/bin/env python
#
# Copyright (c) 2018 Martin Pieuchot <mpi@grenadille.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# Take LibreOffice (glade) .ui files and check for non accessible widgets

import sys
import argparse
import lxml.etree as ET

pflag = False
Wflag = False
errors = 0
widgets_ignored = ['GtkBox', 'GtkVBox']


def errstr(elm):
    """
    Print the line number or the XML class path.
    """
    global pflag

    if pflag:
        path = elm.attrib['class']
        elm = elm.getparent()
        while elm is not None:
            klass = elm.attrib.get('class')
            if klass is not None:
                path = klass + '/' + path
            elm = elm.getparent()
        return path
    return str(elm.sourceline)


def err(filename, elm, msg):
    global errors

    errors += 1
    prefix = "%s:%s ERROR: " % (filename, errstr(elm))
    print(prefix + msg)


def warn(filename, elm, msg):
    global Wflag, errors

    if Wflag:
        errors += 1

    prefix = "%s:%s WARNING: " % (filename, errstr(elm))
    print(prefix + msg)


def check_a11y_relation(filename, root):
    """
    Emit an error message if any of the 'object' elements of the XML
    document represented by `root' doesn't comply with Accessibility
    rules.
    """
    for obj in root.iter('object'):
        if obj.attrib['class'] in widgets_ignored:
            continue

        if obj.attrib['class'] == 'GtkLabel':
            # Case 0: A 'GtkLabel' must contain one or more "label-for"
            # pointing to existing elements or...
            rels = obj.findall("accessibility/relation[@type='label-for']")
            if len(rels) > 0:
                for rel in rels:
                    target = rel.attrib['target']
                    objects = root.iterfind(".//object[@id='%s']" % target)
                    if len(list(objects)) == 0:
                        err(filename, rel, "target '%s' not found" % target)
                continue

            # ...a single "mnemonic_widget"
            properties = obj.findall("property[@name='mnemonic_widget']")
            if len(properties) > 1:
                lines = ', '.join([str(p.sourceline) for p in properties])
                err(filename, obj, "too many mnemonic_widgets: lines %s" %
                    lines)
                continue
            if len(properties) == 1:
                prop = properties[0]
                objects = root.iterfind(".//object[@id='%s']" % prop.text)
                if len(list(objects)) == 0:
                    err(filename, prop, "mnemonic_widget '%s' not found" %
                        prop.text)
                continue
            warn(filename, obj, "'%s' has no label-for nor mnemonic_widget" %
                 obj.attrib['class'])
            continue

        # Case 1: has a <child internal-child="accessible"> sub-element
        children = obj.findall("child[@internal-child='accessible']")
        if children:
            if len(children) > 1:
                err(filename, obj, "multiple accessible children")
            continue

        # Case 2: has an <accessibility> sub-element with a "labelled-by"
        # <relation> pointing to an existing element.
        rels = obj.findall("accessibility/relation[@type='labelled-by']")
        if len(rels) > 0:
            for rel in rels:
                target = rel.attrib['target']
                targets = root.iterfind(".//object[@id='%s']" % target)
                if len(list(targets)) == 0:
                    err(filename, rel, "target '%s' not found" % target)
            continue

        # Case 3/4: has an ID...
        oid = obj.attrib.get('id')
        if oid is not None:
            # ...referenced by a single "label-for" <relation>
            rels = root.iterfind(".//relation[@target='%s']" % oid)
            labelfor = [r for r in rels if r.attrib.get('type') == 'label-for']
            if len(labelfor) == 1:
                continue
            if len(labelfor) > 1:
                lines = ', '.join([str(l.sourceline) for l in labelfor])
                err(filename, obj, "'%s' has multiple relations: lines %s" %
                    (obj.attrib['class'], lines))
                continue

            # ...referenced by a single "mnemonic_widget"
            props = root.iterfind(".//property[@name='mnemonic_widget']")
            props = [p for p in props if p.text == oid]
            if len(props) == 1:
                continue
            if len(props) > 1:
                lines = ', '.join([str(p.sourceline) for p in props])
                err(filename, obj, "'%s' has multiple mnemonic_widget:"
                    " lines %s" % (obj.attrib['class'], lines))
                continue

            warn(filename, obj, "'%s' has no relation" % oid)
            continue

        klass = obj.attrib['class']
        warn(filename, obj, "'%s' is missing some a11y love" % klass)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', action='store_true',
                        help="print path in messages")
    parser.add_argument('-W', action='store_true',
                        help="make all warnings into errors")
    parser.add_argument('file', nargs='+', help="glade .ui file")
    parser.add_argument('-i', dest='widgets', help="list of widgets to ignore")
    parser.add_argument('-I', action='store_true',
                        help="do not ignore any widget")

    args = parser.parse_args()

    if args.widgets is not None:
        widgets_ignored.extend(args.widgets.split(','))

    if args.I:
        widgets_ignored = []

    pflag = args.p
    Wflag = args.W
    for filename in args.file:
        try:
            tree = ET.parse(filename)
        except ET.ParseError:
            sys.exit("%s: malformated xml file: %s" % (sys.argv[0], filename))
        except IOError:
            sys.exit("%s: non existing file: %s" % (sys.argv[0], filename))

        try:
            check_a11y_relation(filename, tree.getroot())
        except KeyboardInterrupt:
            pass
        except Exception as error:
            import traceback
            traceback.print_exc()
            sys.exit("%s: error parsing file: %s" % (sys.argv[0], filename))

        if errors > 0:
            sys.exit(1)
